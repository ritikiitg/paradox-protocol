<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>PARADOX PROTOCOL</title>


    <script src="https://cdn.tailwindcss.com"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700;800&family=Rajdhani:wght@400;600;700&display=swap"
        rel="stylesheet">

    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        mono: ['"JetBrains Mono"', 'monospace'],
                        display: ['"Rajdhani"', 'sans-serif'],
                    },
                    colors: {
                        'protocol-blue': '#00f0ff',
                        'protocol-red': '#ff003c',
                        'protocol-yellow': '#fcee0a',
                        'protocol-dark': '#0d0d0d',
                        'protocol-gray': '#1a1a1a',
                    },
                    animation: {
                        'pulse-fast': 'pulse 1s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                        'glitch': 'glitch 0.2s linear infinite',
                        'scanline': 'scanline 8s linear infinite',
                        'shake': 'shake 0.4s cubic-bezier(.36,.07,.19,.97) both',
                        'float': 'float 3s ease-in-out infinite',
                        'spin-slow': 'spin 8s linear infinite',
                        'spin-reverse': 'spin 12s linear infinite reverse',
                        'ping-slow': 'ping 2s cubic-bezier(0, 0, 0.2, 1) infinite',
                    },
                    keyframes: {
                        glitch: {
                            '0%': { transform: 'translate(0)' },
                            '20%': { transform: 'translate(-2px, 2px)' },
                            '40%': { transform: 'translate(-2px, -2px)' },
                            '60%': { transform: 'translate(2px, 2px)' },
                            '80%': { transform: 'translate(2px, -2px)' },
                            '100%': { transform: 'translate(0)' },
                        },
                        scanline: {
                            '0%': { backgroundPosition: '0 0' },
                            '100%': { backgroundPosition: '0 100%' },
                        },
                        shake: {
                            '10%, 90%': { transform: 'translate3d(-1px, 0, 0)' },
                            '20%, 80%': { transform: 'translate3d(2px, 0, 0)' },
                            '30%, 50%, 70%': { transform: 'translate3d(-4px, 0, 0)' },
                            '40%, 60%': { transform: 'translate3d(4px, 0, 0)' }
                        },
                        float: {
                            '0%, 100%': { transform: 'translateY(0)' },
                            '50%': { transform: 'translateY(-5px)' },
                        }
                    }
                },
            },
        }
    </script>
    <style>
        body {
            background-color: #050505;
            color: #e0e0e0;
            overflow: hidden;
            touch-action: none;
            user-select: none;
        }

        .scanlines {
            background: linear-gradient(to bottom,
                    rgba(255, 255, 255, 0),
                    rgba(255, 255, 255, 0) 50%,
                    rgba(0, 0, 0, 0.2) 50%,
                    rgba(0, 0, 0, 0.2));
            background-size: 100% 4px;
            animation: scanline 0.2s linear infinite;
            pointer-events: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 50;
            opacity: 0.15;
        }

        .glow-text {
            text-shadow: 0 0 10px currentColor;
        }

        .custom-scrollbar::-webkit-scrollbar {
            width: 4px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 2px;
        }

        .score-anim-enter {
            opacity: 0;
            transform: translateY(20px) scale(0.8);
        }

        .score-anim-enter-active {
            opacity: 1;
            transform: translateY(0) scale(1.1);
            transition: all 300ms cubic-bezier(0.18, 0.89, 0.32, 1.28);
        }

        .score-anim-exit {
            opacity: 1;
            transform: translateY(0) scale(1);
        }

        .score-anim-exit-active {
            opacity: 0;
            transform: translateY(-20px) scale(0.8);
            transition: all 300ms ease-in;
        }
    </style>
</head>

<body>
    <div class="scanlines"></div>
    <div id="root"></div>

    <script type="text/babel" data-presets="react,typescript">
        const { useState, useEffect, useCallback, useMemo, useRef } = React;

        const SoundEngine = {
            ctx: null,
            init: () => {
                if (!SoundEngine.ctx) {
                    SoundEngine.ctx = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (SoundEngine.ctx.state === 'suspended') {
                    SoundEngine.ctx.resume();
                }
            },
            play: (type) => {

                SoundEngine.init();
                const ctx = SoundEngine.ctx;
                const t = ctx.currentTime;

                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.connect(gain);
                gain.connect(ctx.destination);

                switch (type) {
                    case 'MOVE':

                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(800, t);
                        osc.frequency.exponentialRampToValueAtTime(1200, t + 0.05);
                        gain.gain.setValueAtTime(0.05, t);
                        gain.gain.exponentialRampToValueAtTime(0.001, t + 0.05);
                        osc.start(t);
                        osc.stop(t + 0.05);
                        break;
                    case 'MISTAKE':

                        osc.type = 'sawtooth';
                        osc.frequency.setValueAtTime(150, t);
                        osc.frequency.linearRampToValueAtTime(100, t + 0.2);
                        gain.gain.setValueAtTime(0.15, t);
                        gain.gain.exponentialRampToValueAtTime(0.001, t + 0.3);

                        const osc2 = ctx.createOscillator();
                        osc2.type = 'square';
                        osc2.frequency.setValueAtTime(50, t);
                        const gain2 = ctx.createGain();
                        gain2.gain.setValueAtTime(0.05, t);
                        gain2.gain.linearRampToValueAtTime(0, t + 0.2);
                        osc2.connect(gain2);
                        gain2.connect(ctx.destination);
                        osc2.start(t);
                        osc2.stop(t + 0.2);

                        osc.start(t);
                        osc.stop(t + 0.3);
                        break;
                    case 'OVERRIDE':

                        osc.type = 'triangle';
                        osc.frequency.setValueAtTime(200, t);
                        osc.frequency.linearRampToValueAtTime(800, t + 0.3);
                        gain.gain.setValueAtTime(0.1, t);
                        gain.gain.linearRampToValueAtTime(0, t + 0.3);
                        osc.start(t);
                        osc.stop(t + 0.3);
                        break;
                    case 'WIN':

                        osc.type = 'square';
                        osc.frequency.setValueAtTime(440, t);
                        osc.frequency.setValueAtTime(554, t + 0.1); // C#
                        osc.frequency.setValueAtTime(659, t + 0.2); // E
                        gain.gain.setValueAtTime(0.05, t);
                        gain.gain.linearRampToValueAtTime(0, t + 0.5);
                        osc.start(t);
                        osc.stop(t + 0.5);
                        break;
                    case 'START':

                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(50, t);
                        osc.frequency.linearRampToValueAtTime(100, t + 1);
                        gain.gain.setValueAtTime(0, t);
                        gain.gain.linearRampToValueAtTime(0.2, t + 0.5);
                        gain.gain.linearRampToValueAtTime(0, t + 1.5);
                        osc.start(t);
                        osc.stop(t + 1.5);
                        break;
                    case 'DESTROY':

                        osc.type = 'sawtooth';
                        osc.frequency.setValueAtTime(100, t);
                        osc.frequency.exponentialRampToValueAtTime(10, t + 0.5);
                        gain.gain.setValueAtTime(0.2, t);
                        gain.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
                        osc.start(t);
                        osc.stop(t + 0.5);
                        break;
                }
            }
        };

        const Icon = ({ path, className, size = 24, fill = "none" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill={fill} stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>{path}</svg>
        );
        const Zap = (props) => <Icon {...props} path={<polygon points="13 2 3 14 12 14 11 22 21 12 12 12 13 2"></polygon>} />;
        const AlertTriangle = (props) => <Icon {...props} path={<><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z" /><line x1="12" y1="9" x2="12" y2="13" /><line x1="12" y1="17" x2="12.01" y2="17" /></>} />;
        const Timer = (props) => <Icon {...props} path={<><line x1="10" x2="14" y1="2" y2="2" /><line x1="12" x2="15" y1="14" y2="11" /><circle cx="12" cy="14" r="8" /></>} />;
        const ShieldCheck = (props) => <Icon {...props} path={<><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z" /><path d="m9 12 2 2 4-4" /></>} />;
        const Play = (props) => <Icon {...props} path={<polygon points="5 3 19 12 5 21 5 3"></polygon>} />;
        const RefreshCw = (props) => <Icon {...props} path={<><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8" /><path d="M21 3v5h-5" /><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16" /><path d="M8 16H3v5" /></>} />;
        const Trophy = (props) => <Icon {...props} path={<><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6" /><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18" /><path d="M4 22h16" /><path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22" /><path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22" /><path d="M18 2H6v7a6 6 0 0 0 12 0V2Z" /></>} />;
        const ChevronRight = (props) => <Icon {...props} path={<path d="m9 18 6-6-6-6" />} />;
        const Lock = (props) => <Icon {...props} path={<><rect x="3" y="11" width="18" height="11" rx="2" ry="2" /><path d="M7 11V7a5 5 0 0 1 10 0v4" /></>} />;
        const Unlock = (props) => <Icon {...props} path={<><rect x="3" y="11" width="18" height="11" rx="2" ry="2" /><path d="M7 11V7a5 5 0 0 1 9.9-1" /></>} />;
        const TrendingUp = (props) => <Icon {...props} path={<polyline points="23 6 13.5 15.5 8.5 10.5 1 18" />} />;

        const CyberHead = (props) => (
            <svg {...props} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M12 3a8 8 0 0 0-8 8v4a3 3 0 0 0 3 3h10a3 3 0 0 0 3-3v-4a8 8 0 0 0-8-8z" />
                <path d="M4 11h16" />
                <path d="M12 16a2 2 0 1 0 0 4 2 2 0 0 0 0-4" />
                <path d="M12 3v2" />
            </svg>
        );

        const PortalIcon = (props) => (
            <svg {...props} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <circle cx="12" cy="12" r="10" strokeDasharray="4 4" className="animate-spin-slow origin-center" />
                <circle cx="12" cy="12" r="6" />
                <path d="M12 2v4" />
                <path d="M12 18v4" />
                <path d="M2 12h4" />
                <path d="M18 12h4" />
            </svg>
        );

        const GRID_SIZE = 8;
        const MAX_LEVELS = 5;

        const TileType = { Empty: 'EMPTY', Wall: 'WALL', Exit: 'EXIT' };
        const TileColor = { Neutral: 'NEUTRAL', Red: 'RED', Blue: 'BLUE', Green: 'GREEN', Yellow: 'YELLOW' };
        const DirectiveType = { MoveToColor: 'MOVE_TO_COLOR', AvoidColor: 'AVOID_COLOR' };

        const COLOR_MAP = {
            [TileColor.Neutral]: '#2a2a2a',
            [TileColor.Red]: '#7f1d1d',
            [TileColor.Blue]: '#1e3a8a',
            [TileColor.Green]: '#14532d',
            [TileColor.Yellow]: '#713f12',
        };

        const COLOR_BORDER_MAP = {
            [TileColor.Neutral]: '#525252',
            [TileColor.Red]: '#f87171',
            [TileColor.Blue]: '#60a5fa',
            [TileColor.Green]: '#4ade80',
            [TileColor.Yellow]: '#facc15',
        };

        const DIRECTIONS = [
            { x: 0, y: -1, name: 'North' },
            { x: 0, y: 1, name: 'South' },
            { x: -1, y: 0, name: 'West' },
            { x: 1, y: 0, name: 'East' },
        ];

        const generateGrid = (size) => {
            const grid = [];
            const colors = [TileColor.Red, TileColor.Blue, TileColor.Green, TileColor.Yellow];
            for (let y = 0; y < size; y++) {
                const row = [];
                for (let x = 0; x < size; x++) {
                    const isWall = Math.random() > 0.85;
                    const randomColor = colors[Math.floor(Math.random() * colors.length)];
                    row.push({
                        type: isWall ? TileType.Wall : TileType.Empty,
                        color: isWall ? TileColor.Neutral : randomColor,
                        id: `${x}-${y}-${Math.random()}`,
                    });
                }
                grid.push(row);
            }
            grid[0][0] = { type: TileType.Empty, color: TileColor.Blue, id: 'start' };
            grid[size - 1][size - 1] = { type: TileType.Exit, color: TileColor.Neutral, id: 'exit' };
            for (let i = 0; i < size; i++) {
                if (grid[0][i].type === TileType.Wall) grid[0][i].type = TileType.Empty;
                if (grid[i][size - 1].type === TileType.Wall) grid[i][size - 1].type = TileType.Empty;
            }
            return grid;
        };

        const generateDirective = (playerPos, grid) => {
            const neighbors = [];
            DIRECTIONS.forEach(d => {
                const nx = playerPos.x + d.x;
                const ny = playerPos.y + d.y;
                if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                    if (grid[ny][nx].type !== TileType.Wall) neighbors.push({ pos: { x: nx, y: ny }, tile: grid[ny][nx] });
                }
            });

            if (neighbors.length === 0) return { id: Math.random().toString(), type: DirectiveType.MoveToColor, targetColor: TileColor.Blue, description: "SURVIVE" };

            const types = [DirectiveType.MoveToColor, DirectiveType.AvoidColor];
            const selectedType = types[Math.floor(Math.random() * types.length)];
            const randomNeighbor = neighbors[Math.floor(Math.random() * neighbors.length)];
            const color = randomNeighbor.tile.color;
            const colorName = color.charAt(0) + color.slice(1).toLowerCase();

            if (selectedType === DirectiveType.MoveToColor) {
                return { id: Math.random().toString(), type: DirectiveType.MoveToColor, targetColor: color, description: `STEP ON ${colorName}` };
            } else {
                const hasOtherOption = neighbors.some(n => n.tile.color !== color);
                if (hasOtherOption) {
                    return { id: Math.random().toString(), type: DirectiveType.AvoidColor, targetColor: color, description: `AVOID ${colorName}` };
                } else {
                    return { id: Math.random().toString(), type: DirectiveType.MoveToColor, targetColor: color, description: `STEP ON ${colorName}` };
                }
            }
        };

        const checkDirectiveCompliance = (prevPos, newPos, grid, directive) => {
            const tile = grid[newPos.y][newPos.x];
            if (directive.type === DirectiveType.MoveToColor) return tile.color === directive.targetColor;
            if (directive.type === DirectiveType.AvoidColor) return tile.color !== directive.targetColor;
            return true;
        };

        const moveEnemies = (enemies, playerPos, grid) => {
            return enemies.map(enemy => {
                const dx = playerPos.x - enemy.pos.x;
                const dy = playerPos.y - enemy.pos.y;
                let nextPos = { ...enemy.pos };
                if (Math.abs(dx) > Math.abs(dy)) {
                    const step = dx > 0 ? 1 : -1;
                    if (grid[enemy.pos.y][enemy.pos.x + step]?.type !== TileType.Wall) nextPos.x += step;
                    else if (dy !== 0) {
                        const stepY = dy > 0 ? 1 : -1;
                        if (grid[enemy.pos.y + stepY]?.[enemy.pos.x]?.type !== TileType.Wall) nextPos.y += stepY;
                    }
                } else {
                    const step = dy > 0 ? 1 : -1;
                    if (grid[enemy.pos.y + step]?.[enemy.pos.x]?.type !== TileType.Wall) nextPos.y += step;
                    else if (dx !== 0) {
                        const stepX = dx > 0 ? 1 : -1;
                        if (grid[enemy.pos.y][enemy.pos.x + stepX]?.type !== TileType.Wall) nextPos.x += stepX;
                    }
                }
                return { ...enemy, pos: nextPos };
            });
        };

        const processEnemyCollisions = (enemies) => {
            const posMap = {};
            enemies.forEach(e => {
                const key = `${e.pos.x},${e.pos.y}`;
                if (!posMap[key]) posMap[key] = [];
                posMap[key].push(e);
            });

            let survivors = [];
            let eliminatedCount = 0;

            Object.values(posMap).forEach(group => {
                const count = group.length;
                if (count % 2 === 1) {
                    survivors.push(group[0]);
                    eliminatedCount += (count - 1);
                } else {
                    eliminatedCount += count;
                }
            });

            return { survivors, eliminated: eliminatedCount };
        };

        const getLeaderboard = () => {
            const stored = localStorage.getItem('paradox_leaderboard');
            return stored ? JSON.parse(stored) : [];
        };

        const saveScore = (name, level, mistakes, status, score) => {
            const scores = getLeaderboard();
            const newScore = { name, level, mistakes, status, score, timestamp: Date.now() };
            scores.push(newScore);
            scores.sort((a, b) => {
                if (a.score !== b.score) return b.score - a.score;
                if (a.level !== b.level) return b.level - a.level;
                return b.timestamp - a.timestamp;
            });
            const topScores = scores.slice(0, 10);
            localStorage.setItem('paradox_leaderboard', JSON.stringify(topScores));
            return topScores;
        };

        const ScoreNotification = ({ notification }) => {
            if (!notification) return null;
            return (
                <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 z-50 pointer-events-none w-full text-center">
                    <div className="animate-[ping-slow_0.5s_ease-out] text-4xl md:text-6xl font-bold font-display text-protocol-yellow drop-shadow-[0_0_20px_rgba(252,238,10,0.8)] stroke-black tracking-widest">
                        {notification.text}
                    </div>
                </div>
            );
        };

        const Particles = ({ particles }) => {
            return (
                <div className="absolute inset-0 pointer-events-none overflow-hidden">
                    {particles.map(p => (
                        <div
                            key={p.id}
                            className="absolute rounded-full animate-pulse"
                            style={{
                                left: `${p.x}%`,
                                top: `${p.y}%`,
                                width: '6px',
                                height: '6px',
                                backgroundColor: p.color,
                                opacity: 0.8,
                                transform: 'translate(-50%, -50%)',
                                transition: 'all 0.5s ease-out'
                            }}
                        />
                    ))}
                </div>
            )
        }

        const TileComponent = ({ tile, x, y, isPlayer, isEnemy, isMistake, playerPos, isGlobalMistake }) => {
            let bgColor = COLOR_MAP[tile.color];
            let borderColor = COLOR_BORDER_MAP[tile.color];

            if (tile.type === TileType.Wall) {
                bgColor = '#171717';
                borderColor = '#262626';
            } else if (tile.type === TileType.Exit) {
                bgColor = '#1a1a1a';
                borderColor = '#ffffff';
            }

            const getPupilTransform = () => {
                if (!isGlobalMistake || !playerPos || !isEnemy) return 'translate(0px, 0px)';

                const dx = playerPos.x - x;
                const dy = playerPos.y - y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 0.1) return 'translate(0px, 0px)';

                const maxOffset = 8;
                const moveX = (dx / dist) * maxOffset;
                const moveY = (dy / dist) * maxOffset;

                return `translate(${moveX}px, ${moveY}px)`;
            };

            return (
                <div
                    className={`w-full h-full border border-opacity-20 flex items-center justify-center relative transition-colors duration-300 ${isPlayer ? 'z-20' : 'z-0'}`}
                    style={{ backgroundColor: bgColor, borderColor: borderColor }}
                >
                    {tile.type === TileType.Exit && (
                        <div className="absolute inset-0 flex items-center justify-center">
                            <PortalIcon className="w-4/5 h-4/5 text-white animate-spin-slow drop-shadow-[0_0_15px_rgba(255,255,255,0.8)]" />
                            <div className="absolute inset-0 bg-white/20 animate-pulse rounded-full blur-xl transform scale-50"></div>
                        </div>
                    )}

                    {tile.type === TileType.Wall && (
                        <div className="w-full h-full bg-[url('https://www.transparenttextures.com/patterns/carbon-fibre.png')] opacity-20"></div>
                    )}

                    {isEnemy && (
                        <div className="absolute inset-0 flex items-center justify-center z-10 transition-all duration-300 ease-in-out">
                            <div className={`absolute w-[85%] h-[85%] rounded-full border border-protocol-red/20 border-dashed animate-[spin_10s_linear_infinite] ${isGlobalMistake ? 'border-protocol-red shadow-[0_0_15px_#ff003c]' : ''}`}></div>

                            <div className={`absolute w-[65%] h-[65%] rounded-full border border-protocol-red/40 ${isGlobalMistake ? 'bg-red-950/50' : 'bg-black'} shadow-[inset_0_0_10px_#000] flex items-center justify-center overflow-hidden`}>

                                <div className="absolute inset-0 opacity-20 bg-[linear-gradient(0deg,transparent_24%,rgba(255,0,60,0.5)_25%,rgba(255,0,60,0.5)_26%,transparent_27%,transparent_74%,rgba(255,0,60,0.5)_75%,rgba(255,0,60,0.5)_76%,transparent_77%,transparent),linear-gradient(90deg,transparent_24%,rgba(255,0,60,0.5)_25%,rgba(255,0,60,0.5)_26%,transparent_27%,transparent_74%,rgba(255,0,60,0.5)_75%,rgba(255,0,60,0.5)_76%,transparent_77%,transparent)] bg-[length:20px_20px]"></div>

                                <div className="absolute w-full h-[1px] bg-protocol-red/40"></div>
                                <div className="absolute h-full w-[1px] bg-protocol-red/40"></div>
                                <div
                                    className="relative z-10 transition-transform duration-100 ease-out flex items-center justify-center"
                                    style={{ transform: getPupilTransform() }}
                                >
                                    <div className={`w-3 h-3 bg-white rounded-full shadow-[0_0_10px_white] relative z-20 ${isGlobalMistake ? 'scale-125' : 'scale-100'} transition-transform duration-200`}></div>
                                    <div className={`absolute w-6 h-6 rounded-full border border-protocol-red opacity-80 ${isGlobalMistake ? 'animate-ping' : ''}`}></div>
                                    <div className="absolute w-5 h-5 bg-red-500/20 rounded-full blur-[2px]"></div>
                                </div>
                            </div>

                            <div className="absolute w-full h-full rotate-45 pointer-events-none">
                                <div className="absolute top-1 left-1/2 -translate-x-1/2 w-[2px] h-[4px] bg-protocol-red/60"></div>
                                <div className="absolute bottom-1 left-1/2 -translate-x-1/2 w-[2px] h-[4px] bg-protocol-red/60"></div>
                                <div className="absolute left-1 top-1/2 -translate-y-1/2 h-[2px] w-[4px] bg-protocol-red/60"></div>
                                <div className="absolute right-1 top-1/2 -translate-y-1/2 h-[2px] w-[4px] bg-protocol-red/60"></div>
                            </div>
                        </div>
                    )}

                    {isPlayer && (
                        <div className="absolute inset-0 flex items-center justify-center z-20">

                            <div className={`absolute w-[90%] h-[90%] rounded-full border border-dashed transition-all duration-500 animate-[spin_4s_linear_infinite] ${isMistake ? 'border-protocol-red opacity-60' : 'border-protocol-blue opacity-40'}`}></div>

                            <div className={`absolute w-[78%] h-[78%] rounded-full border-[1.5px] border-t-transparent border-b-transparent transition-all duration-500 animate-[spin_3s_linear_infinite_reverse] ${isMistake ? 'border-protocol-red' : 'border-protocol-blue'}`}></div>

                            <div className={`relative w-[70%] h-[70%] flex items-center justify-center transition-all duration-200 ${isMistake ? 'text-protocol-red drop-shadow-[0_0_15px_rgba(255,0,60,0.8)]' : 'text-protocol-blue drop-shadow-[0_0_15px_rgba(0,240,255,0.6)]'}`}>
                                <svg viewBox="0 0 100 100" className={`w-full h-full ${isMistake ? 'animate-shake' : 'animate-float'}`} fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                                    <path d="M50 15 L82 32 L82 72 L50 88 L18 72 L18 32 Z" fill="#050505" strokeWidth="2.5" />

                                    <path d="M30 25 L70 25 L60 15 L40 15 Z" fill="currentColor" opacity="0.3" stroke="none" />

                                    <path d="M25 42 L75 42 L75 54 L50 60 L25 54 Z" fill={isMistake ? "#ff003c" : "#00f0ff"} className="animate-pulse" stroke="none" />

                                    <path d="M38 75 L62 75 L50 82 Z" fill="currentColor" opacity="0.5" stroke="none" />
                                    <path d="M38 75 L50 82 L62 75" />
                                    <line x1="82" y1="32" x2="70" y2="42" strokeWidth="1.5" />
                                    <line x1="18" y1="32" x2="30" y2="42" strokeWidth="1.5" />

                                    <line x1="50" y1="15" x2="50" y2="35" strokeWidth="1.5" opacity="0.5" />
                                </svg>

                                {isMistake && (
                                    <div className="absolute inset-0 bg-protocol-red/20 animate-pulse rounded-full blur-md"></div>
                                )}
                            </div>
                        </div>
                    )}

                    <div className="absolute inset-0 bg-gradient-to-tr from-white/5 to-transparent pointer-events-none"></div>
                </div>
            );
        };

        const InfoPanel = ({ gameState, onToggleOverride, overrideActive }) => {
            const { currentDirective, mistakes, lastAction, timeFrozen, level, overrides, score } = gameState;
            return (
                <div className="w-full max-w-lg mx-auto mb-4 font-display select-none">
                    <div className="flex justify-between items-end mb-4 px-2">
                        <div>
                            <h1 className="text-2xl font-bold tracking-widest text-protocol-blue uppercase glow-text">Paradox Protocol</h1>
                            <p className="text-xs text-gray-500 font-mono">SECTOR {level}</p>
                        </div>
                        <div className="flex flex-col items-end">
                            <div className="flex items-center gap-2 text-white">
                                <div className="flex flex-col items-end">
                                    <span className="text-3xl font-bold tracking-tighter tabular-nums drop-shadow-[0_0_10px_rgba(255,255,255,0.5)]">{score}</span>
                                    <span className="text-[10px] uppercase tracking-widest text-gray-500">Score</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div className={`relative p-4 border-l-4 rounded-r-lg bg-gray-900 shadow-lg transition-all duration-300 overflow-hidden ${timeFrozen ? 'border-protocol-blue shadow-[0_0_20px_rgba(0,240,255,0.2)]' : 'border-protocol-red shadow-[0_0_20px_rgba(255,0,60,0.2)]'}`}>
                        {!timeFrozen && <div className="absolute inset-0 bg-protocol-red opacity-10 animate-pulse pointer-events-none"></div>}

                        <div className="flex justify-between items-center relative z-10">
                            <div className="flex-1">
                                <p className="text-xs text-gray-400 uppercase tracking-widest mb-1">Current Protocol</p>
                                <h2 className={`text-xl md:text-2xl font-bold uppercase tracking-tight truncate ${currentDirective.type === DirectiveType.AvoidColor ? 'text-protocol-red' : 'text-white'}`}>
                                    {currentDirective.description}
                                </h2>
                            </div>

                            <div className="flex flex-col items-center justify-center w-14 h-14 ml-2 rounded bg-black border border-gray-800 shrink-0">
                                {timeFrozen ? (
                                    <ShieldCheck className="text-protocol-blue mb-1" size={20} />
                                ) : (
                                    <Timer className="text-protocol-red animate-spin mb-1" size={20} />
                                )}
                            </div>
                        </div>

                        <div className="mt-2 h-6 flex justify-between items-center">
                            <div className="flex items-center">
                                {lastAction === 'PERFECT' && <span className="text-sm text-protocol-blue font-mono flex items-center gap-2 animate-pulse"><ShieldCheck size={14} /> STABLE</span>}
                                {lastAction === 'MISTAKE' && <span className="text-sm text-protocol-red font-mono flex items-center gap-2 animate-glitch"><Zap size={14} /> ERROR ({mistakes})</span>}
                                {lastAction === 'NONE' && <span className="text-sm text-gray-600 font-mono">WAITING...</span>}
                            </div>

                            <button
                                onClick={onToggleOverride}
                                disabled={overrides <= 0}
                                className={`flex items-center gap-1 px-2 py-0.5 rounded text-xs font-bold uppercase tracking-wider transition-all
                                    ${overrideActive
                                        ? 'bg-protocol-yellow text-black shadow-[0_0_10px_rgba(252,238,10,0.6)] animate-pulse'
                                        : overrides > 0
                                            ? 'bg-gray-800 text-protocol-yellow hover:bg-gray-700 border border-protocol-yellow/30'
                                            : 'bg-gray-900 text-gray-600 border border-gray-800'
                                    }
                                `}
                            >
                                {overrideActive ? <Unlock size={12} /> : <Lock size={12} />}
                                Override ({overrides})
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        const Leaderboard = ({ onRestart, gameState }) => {
            const [name, setName] = useState('');
            const [submitted, setSubmitted] = useState(false);
            const [highScores, setHighScores] = useState([]);

            useEffect(() => {
                setHighScores(getLeaderboard());
                SoundEngine.play(gameState.status === 'WON' ? 'WIN' : 'MISTAKE');
            }, []);

            const handleSubmit = (e) => {
                e.preventDefault();
                if (!name.trim()) return;
                const newScores = saveScore(name.toUpperCase(), gameState.level, gameState.mistakes, gameState.status, gameState.score);
                setHighScores(newScores);
                setSubmitted(true);
            };

            return (
                <div className="absolute inset-0 bg-black/95 z-50 flex flex-col items-center justify-center p-6 animate-in fade-in duration-500 font-display">
                    <h2 className={`text-5xl md:text-6xl font-bold mb-2 ${gameState.status === 'WON' ? 'text-protocol-blue' : 'text-protocol-red'} tracking-tight glow-text text-center`}>
                        {gameState.status === 'WON' ? 'SEQUENCE COMPLETE' : 'TIMELINE COLLAPSED'}
                    </h2>
                    <p className="text-gray-500 font-mono mb-8 uppercase tracking-widest text-sm">
                        {gameState.status === 'WON' ? 'Synchronization Rate: 100%' : 'Critical Variance Detected'}
                    </p>
                    <div className="text-4xl font-bold text-white mb-8 tracking-tighter">FINAL SCORE: <span className="text-protocol-yellow">{gameState.score}</span></div>

                    {!submitted ? (
                        <div className="w-full max-w-sm bg-gray-900 border border-gray-800 p-6 rounded-lg shadow-2xl">
                            <div className="flex justify-between font-mono text-sm text-gray-400 mb-2">
                                <span>SECTOR: <span className="text-white">{gameState.level}</span></span>
                                <span>SLIPS: <span className="text-white">{gameState.mistakes}</span></span>
                            </div>

                            <form onSubmit={handleSubmit} className="space-y-4">
                                <div>
                                    <label className="block text-xs uppercase tracking-widest text-protocol-blue mb-2">Identify Agent</label>
                                    <input autoFocus type="text" maxLength={10} value={name} onChange={e => setName(e.target.value)} placeholder="CALLSIGN" className="w-full bg-black border-2 border-gray-700 text-white p-3 font-mono text-xl uppercase focus:border-protocol-blue focus:outline-none focus:shadow-[0_0_15px_rgba(0,240,255,0.3)] transition-all" />
                                </div>
                                <button type="submit" className="w-full py-3 bg-protocol-blue text-black font-bold uppercase tracking-widest hover:bg-white hover:scale-[1.02] transition-all flex items-center justify-center gap-2 shadow-[0_0_15px_rgba(0,240,255,0.4)]">
                                    Upload Data <ChevronRight size={16} />
                                </button>
                            </form>
                        </div>
                    ) : (
                        <div className="w-full max-w-md bg-gray-900 border border-gray-800 rounded-lg shadow-2xl overflow-hidden flex flex-col max-h-[50vh]">
                            <div className="bg-gray-950 p-4 border-b border-gray-800 flex items-center justify-center gap-2">
                                <Trophy className="text-protocol-yellow" size={20} />
                                <h3 className="text-xl font-bold uppercase tracking-widest text-protocol-yellow">Elite Agents</h3>
                            </div>
                            <div className="overflow-y-auto flex-1 p-2 space-y-1 custom-scrollbar">
                                {highScores.map((score, idx) => (
                                    <div key={idx} className={`flex items-center justify-between p-3 rounded ${score.name === name.toUpperCase() && Date.now() - score.timestamp < 2000 ? 'bg-protocol-blue/20 border border-protocol-blue/50' : 'bg-black border border-gray-800'}`}>
                                        <div className="flex items-center gap-3">
                                            <span className={`font-mono font-bold text-lg w-6 ${idx < 3 ? 'text-protocol-yellow' : 'text-gray-600'}`}>#{idx + 1}</span>
                                            <div className="flex flex-col">
                                                <span className="font-bold text-white uppercase tracking-wider">{score.name}</span>
                                                <span className={`text-[10px] uppercase px-1 rounded w-fit ${score.status === 'WON' ? 'bg-protocol-blue/20 text-protocol-blue' : 'bg-protocol-red/20 text-protocol-red'}`}>{score.status}</span>
                                            </div>
                                        </div>
                                        <div className="text-right font-mono text-xs text-gray-400">
                                            <div className="text-protocol-yellow font-bold text-sm">{score.score} PTS</div>
                                            <div>LVL {score.level}</div>
                                        </div>
                                    </div>
                                ))}
                            </div>
                            <div className="p-4 border-t border-gray-800 bg-gray-950">
                                <button onClick={onRestart} className="w-full py-3 bg-white text-black font-bold uppercase tracking-widest hover:bg-protocol-blue transition-colors flex items-center justify-center gap-2">
                                    <RefreshCw size={16} /> Reboot System
                                </button>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        const INITIAL_STATE = {
            status: 'START',
            level: 1,
            grid: [],
            player: { id: 'p1', pos: { x: 0, y: 0 }, type: 'PLAYER' },
            enemies: [],
            gridSize: GRID_SIZE,
            mistakes: 0,
            score: 0,
            timeFrozen: true,
            currentDirective: { id: '0', type: DirectiveType.MoveToColor, targetColor: TileColor.Blue, description: 'INITIALIZING...' },
            turnCount: 0,
            lastAction: 'NONE',
            overrides: 1,
        };

        const App = () => {
            const [gameState, setGameState] = useState(INITIAL_STATE);
            const [shake, setShake] = useState(false);
            const [particles, setParticles] = useState([]);
            const [overrideActive, setOverrideActive] = useState(false);
            const [notification, setNotification] = useState(null);

            // --- FX Helpers ---
            const triggerShake = () => {
                setShake(true);
                setTimeout(() => setShake(false), 400);
            };

            const triggerNotification = (text) => {
                setNotification({ text, id: Date.now() });
                setTimeout(() => setNotification(null), 1500);
            };

            const spawnParticles = (x, y, color) => {
                const newParticles = [];
                for (let i = 0; i < 5; i++) {
                    newParticles.push({
                        id: Math.random(),
                        x: (x / GRID_SIZE) * 100 + 50 / GRID_SIZE + (Math.random() * 10 - 5),
                        y: (y / GRID_SIZE) * 100 + 50 / GRID_SIZE + (Math.random() * 10 - 5),
                        color
                    });
                }
                setParticles(prev => [...prev, ...newParticles]);
                setTimeout(() => {
                    setParticles(prev => prev.slice(newParticles.length));
                }, 500);
            };

            const initLevel = useCallback((level) => {
                SoundEngine.play('START');
                const newGrid = generateGrid(GRID_SIZE);
                const newEnemies = [];
                const enemyCount = Math.min(level + 1, 5);
                for (let i = 0; i < enemyCount; i++) {
                    let ex = Math.floor(Math.random() * GRID_SIZE);
                    let ey = Math.floor(Math.random() * GRID_SIZE);
                    while ((ex < 3 && ey < 3) || newGrid[ey][ex].type === TileType.Wall) {
                        ex = Math.floor(Math.random() * GRID_SIZE);
                        ey = Math.floor(Math.random() * GRID_SIZE);
                    }
                    newEnemies.push({ id: `e-${i}`, pos: { x: ex, y: ey }, type: 'ENEMY' });
                }
                const startPos = { x: 0, y: 0 };
                const initialDirective = generateDirective(startPos, newGrid);

                setGameState(prev => ({
                    ...prev,
                    status: 'PLAYING',
                    level,
                    grid: newGrid,
                    player: { ...prev.player, pos: startPos },
                    enemies: newEnemies,
                    mistakes: 0,
                    score: level === 1 ? 0 : prev.score,
                    timeFrozen: true,
                    currentDirective: initialDirective,
                    turnCount: 0,
                    lastAction: 'NONE',
                    overrides: 1 + Math.floor(level / 2),
                }));
                setOverrideActive(false);
                setNotification(null);
            }, []);

            const toggleOverride = () => {
                if (gameState.overrides > 0) {
                    setOverrideActive(!overrideActive);
                    SoundEngine.play('OVERRIDE');
                }
            };

            const handleMove = useCallback((dx, dy) => {
                if (gameState.status !== 'PLAYING') return;

                const { player, grid, enemies, currentDirective, level, overrides, score } = gameState;
                const newX = player.pos.x + dx;
                const newY = player.pos.y + dy;

                if (newX < 0 || newX >= GRID_SIZE || newY < 0 || newY >= GRID_SIZE) return;

                let currentScore = score;

                // code by r i ti k raj
                if (grid[newY][newX].type === TileType.Wall) {
                    if (overrideActive) {

                        SoundEngine.play('MISTAKE');
                        triggerShake();
                    } else {
                        SoundEngine.play('MISTAKE');
                        triggerShake();


                        let nextEnemies = moveEnemies(enemies, player.pos, grid);


                        const { survivors, eliminated } = processEnemyCollisions(nextEnemies);
                        if (eliminated > 0) {
                            currentScore += eliminated * 100;
                            triggerNotification(`ENEMY ELIMINATED +${eliminated * 100}`);
                            SoundEngine.play('DESTROY');
                        }

                        const hitByEnemy = survivors.some(e => e.pos.x === player.pos.x && e.pos.y === player.pos.y);

                        setGameState(prev => ({
                            ...prev,
                            enemies: survivors,
                            mistakes: prev.mistakes + 1,
                            lastAction: 'MISTAKE',
                            timeFrozen: false,
                            status: hitByEnemy ? 'LOST' : prev.status,
                            score: currentScore - 5
                        }));
                        return;
                    }
                }


                const newPos = { x: newX, y: newY };
                spawnParticles(newX, newY, '#00f0ff');
                SoundEngine.play('MOVE');
                let isCompliant = checkDirectiveCompliance(player.pos, newPos, grid, currentDirective);

                if (overrideActive) {
                    isCompliant = true;
                    setOverrideActive(false);
                }

                let nextEnemies = enemies;
                let timeFrozen = true;
                let lastAction = 'PERFECT';
                let remainingOverrides = overrideActive ? overrides - 1 : overrides;

                if (isCompliant) {
                    currentScore += 1;
                } else {
                    timeFrozen = false;
                    lastAction = 'MISTAKE';
                    SoundEngine.play('MISTAKE');
                    triggerShake();
                    currentScore -= 5;
                    nextEnemies = moveEnemies(enemies, newPos, grid);
                }
                const { survivors, eliminated } = processEnemyCollisions(nextEnemies);

                if (eliminated > 0) {
                    currentScore += eliminated * 100;
                    triggerNotification(`ENEMY ELIMINATED +${eliminated * 100}`);
                    SoundEngine.play('DESTROY');
                    // Add shake for impact
                    triggerShake();
                }

                if (grid[newY][newX].type === TileType.Exit) {
                    currentScore += 25;
                    currentScore += remainingOverrides * 25;

                    if (level >= MAX_LEVELS) {
                        setGameState(prev => ({ ...prev, status: 'WON', player: { ...player, pos: newPos }, score: currentScore }));
                    } else {
                        const newGrid = generateGrid(GRID_SIZE);
                        const newEnemyList = [];
                        const enemyCount = Math.min(level + 1 + 1, 5);
                        for (let i = 0; i < enemyCount; i++) {
                            let ex = Math.floor(Math.random() * GRID_SIZE);
                            let ey = Math.floor(Math.random() * GRID_SIZE);
                            while ((ex < 3 && ey < 3) || newGrid[ey][ex].type === TileType.Wall) {
                                ex = Math.floor(Math.random() * GRID_SIZE);
                                ey = Math.floor(Math.random() * GRID_SIZE);
                            }
                            newEnemyList.push({ id: `e-${i}`, pos: { x: ex, y: ey }, type: 'ENEMY' });
                        }
                        const startPos = { x: 0, y: 0 };
                        const initialDirective = generateDirective(startPos, newGrid);
                        const nextLevel = level + 1;

                        setGameState({
                            status: 'PLAYING',
                            level: nextLevel,
                            grid: newGrid,
                            player: { ...player, pos: startPos },
                            enemies: newEnemyList,
                            mistakes: 0,
                            score: currentScore,
                            timeFrozen: true,
                            currentDirective: initialDirective,
                            turnCount: 0,
                            lastAction: 'NONE',
                            overrides: 1 + Math.floor(nextLevel / 2),
                        });
                        setOverrideActive(false);
                        setNotification(null);
                        SoundEngine.play('WIN');
                    }
                    return;
                }

                const nextDirective = generateDirective(newPos, grid);
                const hitByEnemy = survivors.some(e => e.pos.x === newX && e.pos.y === newY);

                setGameState(prev => ({
                    ...prev,
                    player: { ...prev.player, pos: newPos },
                    enemies: survivors,
                    currentDirective: nextDirective,
                    mistakes: isCompliant ? prev.mistakes : prev.mistakes + 1,
                    timeFrozen,
                    lastAction,
                    overrides: remainingOverrides,
                    turnCount: prev.turnCount + 1,
                    status: hitByEnemy ? 'LOST' : prev.status,
                    score: currentScore
                }));

            }, [gameState, initLevel, overrideActive]);

            // --- Touch & Key Controls ---
            const [touchStart, setTouchStart] = useState(null);
            const [touchEnd, setTouchEnd] = useState(null);
            const minSwipeDistance = 50;

            const onTouchStart = (e) => { setTouchEnd(null); setTouchStart({ x: e.targetTouches[0].clientX, y: e.targetTouches[0].clientY }); };
            const onTouchMove = (e) => { setTouchEnd({ x: e.targetTouches[0].clientX, y: e.targetTouches[0].clientY }); };
            const onTouchEnd = () => {
                if (!touchStart || !touchEnd) return;
                const dx = touchStart.x - touchEnd.x;
                const dy = touchStart.y - touchEnd.y;
                if (Math.abs(dx) > Math.abs(dy)) {
                    if (dx > minSwipeDistance) handleMove(-1, 0);
                    else if (dx < -minSwipeDistance) handleMove(1, 0);
                } else {
                    if (dy > minSwipeDistance) handleMove(0, -1);
                    else if (dy < -minSwipeDistance) handleMove(0, 1);
                }
            };

            useEffect(() => {
                const handleKeyDown = (e) => {
                    switch (e.key) {
                        case 'ArrowUp': case 'w': case 'W': handleMove(0, -1); break;
                        case 'ArrowDown': case 's': case 'S': handleMove(0, 1); break;
                        case 'ArrowLeft': case 'a': case 'A': handleMove(-1, 0); break;
                        case 'ArrowRight': case 'd': case 'D': handleMove(1, 0); break;
                        case ' ': toggleOverride(); break;
                    }
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [handleMove, overrideActive, gameState.overrides]);

            return (
                <div className={`min-h-screen bg-black text-white flex flex-col items-center justify-center p-4 selection:bg-protocol-blue selection:text-black ${shake ? 'animate-shake' : ''}`}>

                    {gameState.status === 'START' && (
                        <div className="max-w-md text-center space-y-8 animate-in fade-in zoom-in duration-500 font-display z-50">
                            <h1 className="text-5xl md:text-7xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-protocol-blue via-white to-protocol-blue animate-pulse glow-text">
                                PARADOX<br />PROTOCOL
                            </h1>
                            <div className="space-y-4 text-gray-400 font-mono text-sm max-w-sm mx-auto">
                                <p>Welcome, Chrono-Agent.</p>
                                <ul className="text-left space-y-2 bg-gray-900 p-4 rounded border border-gray-800 shadow-xl">
                                    <li className="flex items-center gap-2"><span className="text-protocol-blue"></span> <span>Directives <span className="text-white">FREEZE TIME</span>.</span></li>
                                    <li className="flex items-center gap-2"><span className="text-protocol-red"></span> <span>Errors <span className="text-white">ADVANCE TIME</span>.</span></li>
                                    <li className="flex items-center gap-2"><span className="text-protocol-yellow"></span> <span>Use <span className="text-white">OVERRIDES</span> to bypass rules.</span></li>
                                </ul>
                            </div>
                            <button onClick={() => { SoundEngine.init(); initLevel(1); }} className="group relative px-8 py-4 bg-protocol-blue text-black font-bold text-xl uppercase tracking-widest overflow-hidden transition-all hover:bg-white hover:scale-105 shadow-[0_0_20px_rgba(0,240,255,0.4)]">
                                <span className="relative z-10 flex items-center gap-2">Initialize Sequence <Play size={20} /></span>
                            </button>
                        </div>
                    )}

                    {gameState.status === 'PLAYING' && (
                        <div
                            className="w-full max-w-2xl flex flex-col items-center outline-none relative z-10"
                            onTouchStart={onTouchStart} onTouchMove={onTouchMove} onTouchEnd={onTouchEnd}
                        >
                            <InfoPanel gameState={gameState} onToggleOverride={toggleOverride} overrideActive={overrideActive} />

                            <div className="relative bg-gray-900 p-2 rounded-xl shadow-2xl border border-gray-800 transition-transform duration-75"
                                style={{
                                    aspectRatio: '1/1',
                                    display: 'grid',
                                    gridTemplateColumns: `repeat(${GRID_SIZE}, 1fr)`,
                                    gridTemplateRows: `repeat(${GRID_SIZE}, 1fr)`,
                                    width: '100%',
                                    maxWidth: '500px',
                                    gap: '2px',
                                }}>

                                <Particles particles={particles} />
                                <ScoreNotification notification={notification} />

                                {gameState.grid.map((row, y) => row.map((tile, x) => (
                                    <TileComponent
                                        key={tile.id}
                                        tile={tile}
                                        x={x} y={y}
                                        isPlayer={gameState.player.pos.x === x && gameState.player.pos.y === y}
                                        isEnemy={gameState.enemies.some(e => e.pos.x === x && e.pos.y === y)}
                                        isMistake={gameState.player.pos.x === x && gameState.player.pos.y === y && gameState.lastAction === 'MISTAKE'}
                                        playerPos={gameState.player.pos}
                                        isGlobalMistake={gameState.lastAction === 'MISTAKE'}
                                    />
                                )))}
                            </div>

                            <div className="mt-8 grid grid-cols-3 gap-2 md:hidden">
                                <div></div>
                                <button className="w-16 h-16 bg-gray-800 rounded active:bg-protocol-blue flex items-center justify-center border border-gray-700 shadow-lg" onClick={() => handleMove(0, -1)}><div className="w-0 h-0 border-l-[8px] border-l-transparent border-r-[8px] border-r-transparent border-b-[12px] border-b-white"></div></button>
                                <div></div>
                                <button className="w-16 h-16 bg-gray-800 rounded active:bg-protocol-blue flex items-center justify-center border border-gray-700 shadow-lg" onClick={() => handleMove(-1, 0)}><div className="w-0 h-0 border-t-[8px] border-t-transparent border-b-[8px] border-b-transparent border-r-[12px] border-r-white"></div></button>
                                <button className={`w-16 h-16 rounded flex items-center justify-center border shadow-lg ${overrideActive ? 'bg-protocol-yellow text-black' : 'bg-gray-800 text-protocol-yellow border-gray-700'}`} onClick={toggleOverride}>{overrideActive ? <Unlock /> : <Lock />}</button>
                                <button className="w-16 h-16 bg-gray-800 rounded active:bg-protocol-blue flex items-center justify-center border border-gray-700 shadow-lg" onClick={() => handleMove(1, 0)}><div className="w-0 h-0 border-t-[8px] border-t-transparent border-b-[8px] border-b-transparent border-l-[12px] border-l-white"></div></button>
                                <div></div>
                                <button className="w-16 h-16 bg-gray-800 rounded active:bg-protocol-blue flex items-center justify-center border border-gray-700 shadow-lg" onClick={() => handleMove(0, 1)}><div className="w-0 h-0 border-l-[8px] border-l-transparent border-r-[8px] border-r-transparent border-t-[12px] border-t-white"></div></button>
                                <div></div>
                            </div>

                            <div className="mt-6 hidden md:flex gap-8 text-gray-500 font-mono text-xs uppercase tracking-widest opacity-60">
                                <span>WASD / ARROWS to Move</span>
                                <span>SPACE to Override</span>
                            </div>
                        </div>
                    )}

                    {(gameState.status === 'WON' || gameState.status === 'LOST') && (
                        <Leaderboard onRestart={() => initLevel(1)} gameState={gameState} />
                    )}
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);

    </script>
</body>

</html>